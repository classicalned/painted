<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Haunted Painting – Display</title>
<style>
  html,body{margin:0;height:100%;background:#111;}
  #stage{position:relative; width:100vw; height:100vh; overflow:hidden; background:#111;}
  .layer{
    position:absolute; inset:0;
    background-size:cover; background-position:center;
    opacity:0; transition:opacity 2000ms ease; /* keep in sync with FADE_MS */
  }
  .show{opacity:1;}
  #pre{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:#888;font:16px system-ui}
</style>
</head>
<body>
<div id="stage">
  <div id="bg"   class="layer"></div>
  <div id="posA" class="layer"></div><!-- alt layer A -->
  <div id="posB" class="layer"></div><!-- alt layer B -->
  <div id="final" class="layer"></div>
  <div id="pre">Loading…</div>
</div>

<!-- Firebase (compat SDK) -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>
<script>
// ✅ Your Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyA-qhu_bH-GSKrWwAeUUmuxh5EbSrGgOrE",
  authDomain: "haunted-painting.firebaseapp.com",
  databaseURL: "https://haunted-painting-default-rtdb.firebaseio.com",
  projectId: "haunted-painting",
  storageBucket: "haunted-painting.firebasestorage.app",
  messagingSenderId: "543448897329",
  appId: "1:543448897329:web:548f8e73300484977ec210",
  measurementId: "G-4WTEQ9TRYD"
};

firebase.initializeApp(firebaseConfig);
const db  = firebase.database();
const ref = db.ref("rooms/house01");

// DOM
const bg   = document.getElementById('bg');
const posA = document.getElementById('posA');
const posB = document.getElementById('posB');
const fin  = document.getElementById('final');
const pre  = document.getElementById('pre');

// Assets
const ASSETS = {
  bg: "assets/bg/house_plate.jpg",
  pos: ["pos1.png","pos2.png","pos3.png","pos4.png","pos5.png","pos6.png"].map(p=>"assets/subject/"+p)
  // finals loaded at runtime: assets/finals/{CARD}.png
};

const FADE_MS = 2000; // must match CSS transition above

let loaded = new Set();
function preload(src){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res(src); i.onerror=()=>res(src); i.src=src; }); }

async function init(){
  const toLoad = [ASSETS.bg, ...ASSETS.pos];
  await Promise.all(toLoad.map(preload));
  bg.style.backgroundImage = `url(${ASSETS.bg})`;
  bg.classList.add('show');
  pre.remove();

  ref.on('value', snap=>{
    const v = snap.val(); if(!v) return;
    render(Number(v.step||0), (v.card||"AH").toUpperCase());
  });
}

// crossfade state
let currentStep = -1;
let active = 'A';                 // which pos layer is currently showing ('A' or 'B')
let animating = false;            // locked during a fade
let pending = null;               // queued update while fading
let hideTimeout = null;

function safeShow(el){ el.classList.add('show'); }
function safeHide(el){ el.classList.remove('show'); }

function crossfadeTo(imageUrl){
  const incoming = (active === 'A') ? posB : posA;
  const outgoing = (active === 'A') ? posA : posB;

  // keep previous visible during the fade
  safeShow(outgoing);

  // set next image and start fade-in
  incoming.style.backgroundImage = `url(${imageUrl})`;
  requestAnimationFrame(()=> safeShow(incoming));

  // after the fade duration, hide the old one and unlock
  clearTimeout(hideTimeout);
  hideTimeout = setTimeout(()=>{
    safeHide(outgoing);
    animating = false;

    // run any queued update
    if (pending){ const p = pending; pending = null; render(p.step, p.card); }
  }, FADE_MS + 60);

  // flip for next time
  active = (active === 'A') ? 'B' : 'A';
}

function render(step, card){
  if (step === currentStep) return;

  // If we're mid-fade, queue the latest state and bail
  if (animating){
    pending = {step, card};
    return;
  }

  currentStep = step;
  animating = true;

  // hide final unless we're on final
  safeHide(fin);

  if (step <= 5){
    // crossfade between position layers
    crossfadeTo(ASSETS.pos[step]);

  } else {
    // final card fades over whichever pos layer is currently visible
    const finalSrc = `assets/finals/${card}.png`;
    if(!loaded.has(finalSrc)){ preload(finalSrc).then(()=>loaded.add(finalSrc)); }
    fin.style.backgroundImage = `url(${finalSrc})`;
    requestAnimationFrame(()=> safeShow(fin));

    clearTimeout(hideTimeout);
    hideTimeout = setTimeout(()=>{
      animating = false;
      if (pending){ const p = pending; pending = null; render(p.step, p.card); }
    }, FADE_MS + 60);
  }
}

init();
</script>
</body>
</html>
